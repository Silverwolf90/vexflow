<!DOCTYPE html>
<html>

<head>
  <title>VexFlow Tests</title>
  <style type="text/css">
    body {
      padding: 20px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      color: black;
      margin: 0px;
      height: 80%;
    }

    a {
      color: #554;
      text-decoration: none;
      border-bottom: dotted 2px;
    }

    a.button {
      color: green;
      background: #bfb;
      text-decoration: none;
      padding: 5px;
      margin: 2px;
      border: 5px solid #aea;
    }

    div#error {
      width: 60%;
      padding: 10px;
      color: red;
      background: #faa;
      border: 15px solid #d99;
    }

    div.testcanvas {
      font-family: Arial, sans-serif;
      font-size: 18px;
      color: #554;
    }

    div.testcanvas .vex-tabdiv {
      background: white;
    }

    div.testcanvas .name {
      font-family: Arial, sans-serif;
      font-size: 18px;
      color: #447;
    }

  </style>

  <script src="opentype.js"></script>
  <script src="../../tests/support/jquery.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js"></script>

  <!-- VexFlow Sources -->
  <script src="../header.js"></script>
  <script src="../vex.js"></script>
  <script src="../flow.js"></script>
  <script src="../fraction.js"></script>
  <script src="../fonts/gonville_font.js"></script>
  <script src="../fonts/gonville_metrics.js"></script>
  <script src="../glyph.js"></script>
  <script src="../tables.js"></script>
  <script src="../stave.js"></script>
  <script src="../staveconnector.js"></script>
  <script src="../tabstave.js"></script>
  <script src="../voice.js"></script>
  <script src="../voicegroup.js"></script>
  <script src="../modifier.js"></script>
  <script src="../modifiercontext.js"></script>
  <script src="../accidental.js"></script>
  <script src="../dot.js"></script>
  <script src="../tickcontext.js"></script>
  <script src="../tickable.js"></script>
  <script src="../note.js"></script>
  <script src="../bend.js"></script>
  <script src="../stem.js"></script>
  <script src="../notehead.js"></script>
  <script src="../stemmablenote.js"></script>
  <script src="../stavenote.js"></script>
  <script src="../tabnote.js"></script>
  <script src="../barnote.js"></script>
  <script src="../clefnote.js"></script>
  <script src="../timesignote.js"></script>
  <script src="../ghostnote.js"></script>
  <script src="../formatter.js"></script>
  <script src="../stavetie.js"></script>
  <script src="../stavehairpin.js"></script>
  <script src="../tabtie.js"></script>
  <script src="../tabslide.js"></script>
  <script src="../beam.js"></script>
  <script src="../vibrato.js"></script>
  <script src="../annotation.js"></script>
  <script src="../tuning.js"></script>
  <script src="../stavemodifier.js"></script>
  <script src="../keysignature.js"></script>
  <script src="../timesignature.js"></script>
  <script src="../clef.js"></script>
  <script src="../music.js"></script>
  <script src="../keymanager.js"></script>
  <script src="../renderer.js"></script>
  <script src="../stavebarline.js"></script>
  <script src="../stavevolta.js"></script>
  <script src="../staverepetition.js"></script>
  <script src="../stavesection.js"></script>
  <script src="../stavetempo.js"></script>
  <script src="../stavetext.js"></script>
  <script src="../articulation.js"></script>
  <script src="../tremolo.js"></script>
  <script src="../raphaelcontext.js"></script>
  <script src="../canvascontext.js"></script>
  <script src="../tuplet.js"></script>
  <script src="../boundingbox.js"></script>
  <script src="../textnote.js"></script>
  <script src="../strokes.js"></script>
  <script src="../stringnumber.js"></script>
  <script src="../frethandfinger.js"></script>
  <script src="../gracenote.js"></script>
  <script src="../gracenotegroup.js"></script>
  <script src="../curve.js"></script>
  <script src="../staveline.js"></script>
  <script src="../crescendo.js"></script>
  <script src="../ornament.js"></script>
  <script src="../pedalmarking.js"></script>
  <script src="../textbracket.js"></script>
  <script src="../textdynamics.js"></script>
  <script>

  var METADATA;
  $.getJSON('glyphnames.json', function(glyphNames){
    $.getJSON('bravura_metadata.json', function(metadata){
      METADATA = metadata;
      function getCodepointForName(name){
        var glyphData = glyphNames[name];
        if (!glyphData) {
          return false;
        }
        var codepoint = glyphData.codepoint;
        return codepoint;
      }

      function getNameForCodepoint(codepoint){
        return _.find(Object.keys(glyphNames), function(name){
          return glyphNames[name].codepoint === codepoint;
        });
      }

      function getOutline(glyph) {
        var outline = "";
        glyph.path.commands.forEach(function(cmd){
          switch (cmd.type) {
            case "M":
              outline += createOutlineCommand("m", [cmd.x, -cmd.y]);
              break;
            case "L":
              outline += createOutlineCommand("l", [cmd.x, -cmd.y]);
              break;
            case "Q":
              outline += createOutlineCommand("q", [cmd.x1, -cmd.y1, cmd.x, -cmd.y]);
              break;
            case "C":
              outline += createOutlineCommand("b", [cmd.x, -cmd.y, cmd.x1, -cmd.y1, cmd.x2, -cmd.y2]);
              break;
            case "Z":
              break;
          } 
        });
        return outline.substr(0, outline.length - 1);
      }

      function createOutlineCommand(type, points) {
        return points.reduce(function(str, point){
          return str + " " + point; 
        }, type) + " ";
      }

      function getBoundingCoords(bb){
        return {
          "SW": {
            x: bb.bBoxSW[0],
            y: bb.bBoxSW[1]
          },
          "NE": {
            x: bb.bBoxNE[0],
            y: bb.bBoxNE[1]
          },
          "NW": {
            x: bb.bBoxSW[0],
            y: bb.bBoxSW[1] + (bb.bBoxNE[1] - bb.bBoxSW[1])
          },
          "SE": {
            x: bb.bBoxNE[0],
          y: bb.bBoxNE[1] + (bb.bBoxSW[1] - bb.bBoxNE[1])
          }
        };
      }

      var glyphNameCodepointMap = {};
      var codepoints = [];
      var sortedGlyphNames = [];
      var usedGlyphNames = Object.keys(Vex.Flow.Font.Gonville.Metrics);

      usedGlyphNames.forEach(function(glyphName){
        var codepoint = getCodepointForName(glyphName);
        if (!codepoint) return;
        glyphNameCodepointMap[glyphName] = codepoint;
        codepoints.push(codepoint);
        sortedGlyphNames.push(glyphName); 
      });

      var ctx = document.getElementById("draw").getContext('2d');

      opentype.load('Bravura.otf', function (err, font) {
        if (err) {
          alert('Font could not be loaded: ' + err);
        } else {

          var glyphIndices = codepoints.reduce(function(indices, codepoint){
            var index = font.cffEncoding.charset.indexOf("uni" + codepoint.substr(2));
            return indices.concat([index]);
          }, []);

          var glyphs = {};

          glyphIndices.forEach(function(glyphIndex, index){
            var glyph = font.glyphs[glyphIndex];
            var outline = getOutline(glyph);

            glyphs[sortedGlyphNames[index]] = {
              advanceWidth: glyph.advanceWidth,
              o: outline,
              x_min: glyph.xMin,
              x_max: glyph.xMax,
              y_min: glyph.yMin,
              y_max: glyph.yMax
            };
          });

          var fontObject = {
            "glyphs": glyphs,
            "cssFontWeight":"normal",
            "ascender": font.ascender,
            "underlinePosition":-125,
            "cssFontStyle":"normal",
            "boundingBox":{
              "yMin":font.tables.head.yMin,
                "xMin":font.tables.head.xMin,
                "yMax":font.tables.head.yMax,
                "xMax":font.tables.head.xMax
            },
            "resolution":font.unitsPerEm,
            "descender": font.descender,
            "familyName":"Bravura",
            "lineHeight":4093,
            "underlineThickness":50
          };

          var scale = 1 / fontObject.resolution * 72;

          var x = 20;
          var y = 100;
          Object.keys(glyphs).forEach(function(glyphName, index){
            var glyph = glyphs[glyphName];

            var width = glyph.advanceWidth * scale;  
            if (x + width > 1600){
              x = 0;
              y += 100;
            }

            Vex.Flow.Glyph.renderOutline(ctx, glyph.o.split(' '), scale, x, y);

            var bb = METADATA.glyphBBoxes[glyphName];
            var bbCoords = getBoundingCoords(bb);

            glyph.bb = bbCoords;

            var cutouts = METADATA.glyphsWithAnchors[glyphName];
            if (cutouts) {
              drawCutOuts(ctx, bbCoords, cutouts, x, y);
            }

            if (bb) {
              drawBoundingBox(ctx, bb, x, y);
            }

            function drawBoundingBox(ctx, bb, x, y){
              var rect = {
                x: emsToPixels(bb.bBoxSW[0]) + x,
                y: -emsToPixels(bb.bBoxSW[1]) + y,
                w: emsToPixels(bb.bBoxNE[0] - bb.bBoxSW[0]),
                h: -emsToPixels(bb.bBoxNE[1] - bb.bBoxSW[1])
              };

              drawRectangle(ctx, rect.x, rect.y, rect.w, rect.h);
            }

            function drawCutOuts(ctx, coords, cutouts, x, y) {
              var cutoutPositions = ["NE", "NW", "SE", "SW"];

              cutoutPositions.forEach(function(cutOutPosition){
                drawCutOut(ctx, coords[cutOutPosition], cutouts["cutOut" + cutOutPosition], x, y);
              });
            }

            function drawCutOut(ctx, origin, cutOut) {
              if (cutOut) {
                var rect = {
                  x: emsToPixels(origin.x) + x,
                  y: -emsToPixels(origin.y) + y,
                  w: emsToPixels(cutOut[0] - origin.x),
                  h: -emsToPixels(cutOut[1] - origin.y)
                };

                drawRectangle(ctx, rect.x, rect.y, rect.w, rect.h, "green");
              }
            }

            function drawRectangle(ctx, x, y, w, h, color) {
              ctx.save();
              ctx.strokeStyle = color || "red";
              ctx.strokeRect(x, y, w, h);
              ctx.restore();
            }

            function emsToPixels(ems){
              return ems * 250 * scale;
            }

            x += width + 20;
          });

          $("textarea").html("Vex.Flow.Font.Bravura = " + JSON.stringify(fontObject));
        }
      });
    });
  });
  </script>
</head>
<body>

<textarea></textarea>
<br>
<canvas id="draw" width="1600" height="800"></canvas>

</body>
</html>